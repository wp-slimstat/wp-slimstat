{"version":3,"file":"UserInteractionsHandler.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/handlers/UserInteractionsHandler.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\nimport type {HandlerName} from './types.js';\n\n// This handler serves two purposes. It generates a list of events that are\n// used to show user clicks in the timeline. It is also used to gather\n// EventTimings into Interactions, which we use to show interactions and\n// highlight long interactions to the user, along with INP.\n\n// We don't need to know which process / thread these events occurred in,\n// because they are effectively global, so we just track all that we find.\nconst allEvents: Types.Events.EventTimingBeginOrEnd[] = [];\n\nconst beginCommitCompositorFrameEvents: Types.Events.BeginCommitCompositorFrame[] = [];\nconst parseMetaViewportEvents: Types.Events.ParseMetaViewport[] = [];\n\nexport const LONG_INTERACTION_THRESHOLD = Helpers.Timing.milliToMicro(Types.Timing.Milli(200));\n\nconst INP_GOOD_TIMING = LONG_INTERACTION_THRESHOLD;\nconst INP_MEDIUM_TIMING = Helpers.Timing.milliToMicro(Types.Timing.Milli(500));\n\nexport interface UserInteractionsData {\n  /** All the user events we found in the trace */\n  allEvents: readonly Types.Events.EventTimingBeginOrEnd[];\n  /** All the BeginCommitCompositorFrame events we found in the trace */\n  beginCommitCompositorFrameEvents: readonly Types.Events.BeginCommitCompositorFrame[];\n  /** All the ParseMetaViewport events we found in the trace */\n  parseMetaViewportEvents: readonly Types.Events.ParseMetaViewport[];\n  /** All the interaction events we found in the trace that had an\n   * interactionId and a duration > 0\n   **/\n  interactionEvents: readonly Types.Events.SyntheticInteractionPair[];\n  /** If the user rapidly generates interaction events (think typing into a\n   * text box), in the UI we only really want to show the user the longest\n   * interaction in that set.\n   * For example picture interactions like this:\n   * ===[interaction A]==========\n   *       =[interaction B]======\n   *            =[interaction C]=\n   *\n   * These events all end at the same time, and so in this instance we only want\n   * to show the first interaction A on the timeline, as that is the longest one\n   * and the one the developer should be focusing on. So this array of events is\n   * all the interaction events filtered down, removing any nested interactions\n   * entirely.\n   **/\n  interactionEventsWithNoNesting: readonly Types.Events.SyntheticInteractionPair[];\n  // The longest duration interaction event. Can be null if the trace has no interaction events.\n  longestInteractionEvent: Readonly<Types.Events.SyntheticInteractionPair>|null;\n  // All interactions that went over the interaction threshold (200ms, see https://web.dev/inp/)\n  interactionsOverThreshold: Readonly<Set<Types.Events.SyntheticInteractionPair>>;\n}\n\nlet longestInteractionEvent: Types.Events.SyntheticInteractionPair|null = null;\n\nconst interactionEvents: Types.Events.SyntheticInteractionPair[] = [];\nconst interactionEventsWithNoNesting: Types.Events.SyntheticInteractionPair[] = [];\nconst eventTimingEndEventsById = new Map<string, Types.Events.EventTimingEnd>();\nconst eventTimingStartEventsForInteractions: Types.Events.EventTimingBegin[] = [];\n\nexport function reset(): void {\n  allEvents.length = 0;\n  beginCommitCompositorFrameEvents.length = 0;\n  parseMetaViewportEvents.length = 0;\n  interactionEvents.length = 0;\n  eventTimingStartEventsForInteractions.length = 0;\n  eventTimingEndEventsById.clear();\n  interactionEventsWithNoNesting.length = 0;\n  longestInteractionEvent = null;\n}\n\nexport function handleEvent(event: Types.Events.Event): void {\n  if (Types.Events.isBeginCommitCompositorFrame(event)) {\n    beginCommitCompositorFrameEvents.push(event);\n    return;\n  }\n\n  if (Types.Events.isParseMetaViewport(event)) {\n    parseMetaViewportEvents.push(event);\n    return;\n  }\n\n  if (!Types.Events.isEventTiming(event)) {\n    return;\n  }\n\n  if (Types.Events.isEventTimingEnd(event)) {\n    // Store the end event; for each start event that is an interaction, we need the matching end event to calculate the duration correctly.\n    eventTimingEndEventsById.set(event.id, event);\n  }\n\n  allEvents.push(event);\n\n  // From this point on we want to find events that represent interactions.\n  // These events are always start events - those are the ones that contain all\n  // the metadata about the interaction.\n  if (!event.args.data || !Types.Events.isEventTimingStart(event)) {\n    return;\n  }\n  const {duration, interactionId} = event.args.data;\n  // We exclude events for the sake of interactions if:\n  // 1. They have no duration.\n  // 2. They have no interactionId\n  // 3. They have an interactionId of 0: this indicates that it's not an\n  //    interaction that we care about because it hasn't had its own interactionId\n  //    set (0 is the default on the backend).\n  // See: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/responsiveness_metrics.cc;l=133;drc=40c209a9c365ebb9f16fb99dfe78c7fe768b9594\n\n  if (duration < 1 || interactionId === undefined || interactionId === 0) {\n    return;\n  }\n\n  // Store the start event. In the finalize() function we will pair this with\n  // its end event and create the synthetic interaction event.\n  eventTimingStartEventsForInteractions.push(event);\n}\n\n/**\n * See https://web.dev/better-responsiveness-metric/#interaction-types for the\n * table that defines these sets.\n **/\nconst pointerEventTypes = new Set([\n  'pointerdown',\n  'touchstart',\n  'pointerup',\n  'touchend',\n  'mousedown',\n  'mouseup',\n  'click',\n]);\n\nconst keyboardEventTypes = new Set([\n  'keydown',\n  'keypress',\n  'keyup',\n]);\n\nexport type InteractionCategory = 'KEYBOARD'|'POINTER'|'OTHER';\nexport function categoryOfInteraction(interaction: Types.Events.SyntheticInteractionPair): InteractionCategory {\n  if (pointerEventTypes.has(interaction.type)) {\n    return 'POINTER';\n  }\n  if (keyboardEventTypes.has(interaction.type)) {\n    return 'KEYBOARD';\n  }\n\n  return 'OTHER';\n}\n\n/**\n * We define a set of interactions as nested where:\n * 1. Their end times align.\n * 2. The longest interaction's start time is earlier than all other\n * interactions with the same end time.\n * 3. The interactions are of the same category [each interaction is either\n * categorised as keyboard, or pointer.]\n *\n * =============A=[pointerup]=\n *        ====B=[pointerdown]=\n *        ===C=[pointerdown]==\n *         ===D=[pointerup]===\n *\n * In this example, B, C and D are all nested and therefore should not be\n * returned from this function.\n *\n * However, in this example we would only consider B nested (under A) and D\n * nested (under C). A and C both stay because they are of different types.\n * ========A=[keydown]====\n *   =======B=[keyup]=====\n *    ====C=[pointerdown]=\n *         =D=[pointerup]=\n **/\nexport function removeNestedInteractions(interactions: readonly Types.Events.SyntheticInteractionPair[]):\n    readonly Types.Events.SyntheticInteractionPair[] {\n  /**\n   * Because we nest events only that are in the same category, we store the\n   * longest event for a given end time by category.\n   **/\n  const earliestEventForEndTimePerCategory:\n      Record<InteractionCategory, Map<Types.Timing.Micro, Types.Events.SyntheticInteractionPair>> = {\n        POINTER: new Map(),\n        KEYBOARD: new Map(),\n        OTHER: new Map(),\n      };\n\n  function storeEventIfEarliestForCategoryAndEndTime(interaction: Types.Events.SyntheticInteractionPair): void {\n    const category = categoryOfInteraction(interaction);\n    const earliestEventForEndTime = earliestEventForEndTimePerCategory[category];\n    const endTime = Types.Timing.Micro(interaction.ts + interaction.dur);\n\n    const earliestCurrentEvent = earliestEventForEndTime.get(endTime);\n    if (!earliestCurrentEvent) {\n      earliestEventForEndTime.set(endTime, interaction);\n      return;\n    }\n    if (interaction.ts < earliestCurrentEvent.ts) {\n      earliestEventForEndTime.set(endTime, interaction);\n    } else if (\n        interaction.ts === earliestCurrentEvent.ts &&\n        interaction.interactionId === earliestCurrentEvent.interactionId) {\n      // We have seen in traces that the same interaction can have multiple\n      // events (e.g. a 'click' and a 'pointerdown'). Often only one of these\n      // events will have an event handler bound to it which caused delay on\n      // the main thread, and the others will not. This leads to a situation\n      // where if we pick one of the events that had no event handler, its\n      // processing duration (processingEnd - processingStart) will be 0, but if we\n      // had picked the event that had the slow event handler, we would show\n      // correctly the main thread delay due to the event handler.\n      // So, if we find events with the same interactionId and the same\n      // begin/end times, we pick the one with the largest (processingEnd -\n      // processingStart) time in order to make sure we find the event with the\n      // worst main thread delay, as that is the one the user should care\n      // about.\n      const currentProcessingDuration = earliestCurrentEvent.processingEnd - earliestCurrentEvent.processingStart;\n      const newProcessingDuration = interaction.processingEnd - interaction.processingStart;\n\n      // Use the new interaction if it has a longer processing duration than the existing one.\n      if (newProcessingDuration > currentProcessingDuration) {\n        earliestEventForEndTime.set(endTime, interaction);\n      }\n    }\n\n    // Maximize the processing duration based on the \"children\" interactions.\n    // We pick the earliest start processing duration, and the latest end\n    // processing duration to avoid under-reporting.\n    if (interaction.processingStart < earliestCurrentEvent.processingStart) {\n      earliestCurrentEvent.processingStart = interaction.processingStart;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n    if (interaction.processingEnd > earliestCurrentEvent.processingEnd) {\n      earliestCurrentEvent.processingEnd = interaction.processingEnd;\n      writeSyntheticTimespans(earliestCurrentEvent);\n    }\n  }\n\n  for (const interaction of interactions) {\n    storeEventIfEarliestForCategoryAndEndTime(interaction);\n  }\n\n  // Combine all the events that we have kept from all the per-category event\n  // maps back into an array and sort them by timestamp.\n  const keptEvents = Object.values(earliestEventForEndTimePerCategory)\n                         .flatMap(eventsByEndTime => Array.from(eventsByEndTime.values()));\n  keptEvents.sort((eventA, eventB) => {\n    return eventA.ts - eventB.ts;\n  });\n  return keptEvents;\n}\n\nfunction writeSyntheticTimespans(event: Types.Events.SyntheticInteractionPair): void {\n  const startEvent = event.args.data.beginEvent;\n  const endEvent = event.args.data.endEvent;\n\n  event.inputDelay = Types.Timing.Micro(event.processingStart - startEvent.ts);\n  event.mainThreadHandling = Types.Timing.Micro(event.processingEnd - event.processingStart);\n  event.presentationDelay = Types.Timing.Micro(endEvent.ts - event.processingEnd);\n}\n\nexport async function finalize(): Promise<void> {\n  const {navigationsByFrameId} = metaHandlerData();\n\n  // For each interaction start event, find the async end event by the ID, and then create the Synthetic Interaction event.\n  for (const interactionStartEvent of eventTimingStartEventsForInteractions) {\n    const endEvent = eventTimingEndEventsById.get(interactionStartEvent.id);\n    if (!endEvent) {\n      // If we cannot find an end event, bail and drop this event.\n      continue;\n    }\n    const {type, interactionId, timeStamp, processingStart, processingEnd} = interactionStartEvent.args.data;\n    if (!type || !interactionId || !timeStamp || !processingStart || !processingEnd) {\n      // A valid interaction event that we care about has to have a type (e.g. pointerdown, keyup).\n      // We also need to ensure it has an interactionId and various timings. There are edge cases where these aren't included in the trace event.\n      continue;\n    }\n\n    // In the future we will add microsecond timestamps to the trace events…\n    // (See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/window_performance.cc;l=900-901;drc=b503c262e425eae59ced4a80d59d176ed07152c7 )\n    // …but until then we can use the millisecond precision values that are in\n    // the trace event. To adjust them to be relative to the event.ts and the\n    // trace timestamps, for both processingStart and processingEnd we subtract\n    // the event timestamp (NOT event.ts, but the timeStamp millisecond value\n    // emitted in args.data), and then add that value to the event.ts. This\n    // will give us a processingStart and processingEnd time in microseconds\n    // that is relative to event.ts, and can be used when drawing boxes.\n    // There is some inaccuracy here as we are converting milliseconds to microseconds, but it is good enough until the backend emits more accurate numbers.\n    const processingStartRelativeToTraceTime = Types.Timing.Micro(\n        Helpers.Timing.milliToMicro(processingStart) - Helpers.Timing.milliToMicro(timeStamp) +\n            interactionStartEvent.ts,\n    );\n\n    const processingEndRelativeToTraceTime = Types.Timing.Micro(\n        (Helpers.Timing.milliToMicro(processingEnd) - Helpers.Timing.milliToMicro(timeStamp)) +\n        interactionStartEvent.ts);\n\n    // Ultimate frameId fallback only needed for TSC, see comments in the type.\n    const frameId = interactionStartEvent.args.frame ?? interactionStartEvent.args.data.frame ?? '';\n    const navigation = Helpers.Trace.getNavigationForTraceEvent(interactionStartEvent, frameId, navigationsByFrameId);\n    const navigationId = navigation?.args.data?.navigationId;\n    const interactionEvent =\n        Helpers.SyntheticEvents.SyntheticEventsManager.registerSyntheticEvent<Types.Events.SyntheticInteractionPair>({\n          // Use the start event to define the common fields.\n          rawSourceEvent: interactionStartEvent,\n          cat: interactionStartEvent.cat,\n          name: interactionStartEvent.name,\n          pid: interactionStartEvent.pid,\n          tid: interactionStartEvent.tid,\n          ph: interactionStartEvent.ph,\n          processingStart: processingStartRelativeToTraceTime,\n          processingEnd: processingEndRelativeToTraceTime,\n          // These will be set in writeSyntheticTimespans()\n          inputDelay: Types.Timing.Micro(-1),\n          mainThreadHandling: Types.Timing.Micro(-1),\n          presentationDelay: Types.Timing.Micro(-1),\n          args: {\n            data: {\n              beginEvent: interactionStartEvent,\n              endEvent,\n              frame: frameId,\n              navigationId,\n            },\n          },\n          ts: interactionStartEvent.ts,\n          dur: Types.Timing.Micro(endEvent.ts - interactionStartEvent.ts),\n          type: interactionStartEvent.args.data.type,\n          interactionId: interactionStartEvent.args.data.interactionId,\n        });\n    writeSyntheticTimespans(interactionEvent);\n\n    interactionEvents.push(interactionEvent);\n  }\n\n  interactionEventsWithNoNesting.push(...removeNestedInteractions(interactionEvents));\n\n  // Pick the longest interactions from the set that were not nested, as we\n  // know those are the set of the largest interactions.\n  for (const interactionEvent of interactionEventsWithNoNesting) {\n    if (!longestInteractionEvent || longestInteractionEvent.dur < interactionEvent.dur) {\n      longestInteractionEvent = interactionEvent;\n    }\n  }\n}\n\nexport function data(): UserInteractionsData {\n  return {\n    allEvents,\n    beginCommitCompositorFrameEvents,\n    parseMetaViewportEvents,\n    interactionEvents,\n    interactionEventsWithNoNesting,\n    longestInteractionEvent,\n    interactionsOverThreshold: new Set(interactionEvents.filter(event => {\n      return event.dur > LONG_INTERACTION_THRESHOLD;\n    })),\n  };\n}\n\nexport function deps(): HandlerName[] {\n  return ['Meta'];\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/articles/inp#good-score\n */\nexport function scoreClassificationForInteractionToNextPaint(timing: Types.Timing.Micro): ScoreClassification {\n  if (timing <= INP_GOOD_TIMING) {\n    return ScoreClassification.GOOD;\n  }\n\n  if (timing <= INP_MEDIUM_TIMING) {\n    return ScoreClassification.OK;\n  }\n\n  return ScoreClassification.BAD;\n}\n"]}