{"version":3,"file":"MaxPotentialFID.js","sourceRoot":"","sources":["../../../../../../../../front_end/models/trace/lantern/metrics/MaxPotentialFID.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAE7B,OAAO,KAAK,IAAI,MAAM,iBAAiB,CAAC;AACxC,OAAO,KAAK,KAAK,MAAM,mBAAmB,CAAC;AAG3C,OAAO,EAEL,MAAM,GAIP,MAAM,aAAa,CAAC;AAErB,MAAM,eAAgB,SAAQ,MAAM;IAClC,MAAM,KAAc,YAAY;QAC9B,OAAO;YACL,SAAS,EAAE,CAAC;YACZ,UAAU,EAAE,GAAG;YACf,WAAW,EAAE,GAAG;SACjB,CAAC;IACJ,CAAC;IAED,MAAM,CAAU,kBAAkB,CAAC,eAA2B;QAC5D,OAAO,eAAe,CAAC;IACzB,CAAC;IAED,MAAM,CAAU,mBAAmB,CAAC,eAA2B;QAC7D,OAAO,eAAe,CAAC;IACzB,CAAC;IAED,MAAM,CAAU,yBAAyB,CAAC,UAA6B,EAAE,MAAc;QACrF,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;YACtB,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,mBAAmB,CAAC,CAAC;QACnD,CAAC;QAED,4FAA4F;QAC5F,wFAAwF;QACxF,MAAM,WAAW,GAAG,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;YAC/C,MAAM,CAAC,SAAS,CAAC,kBAAkB,CAAC,QAAQ,CAAC;QAErF,MAAM,OAAO,GAAG,eAAe,CAAC,kBAAkB,CAC9C,UAAU,CAAC,WAAW,EACtB,WAAW,CACd,CAAC;QAEF,OAAO;YACL,QAAQ,EAAE,IAAI,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjE,WAAW,EAAE,UAAU,CAAC,WAAW;SACpC,CAAC;IACJ,CAAC;IAED,MAAM,CAAU,OAAO,CAAC,IAAgC,EAAE,MAAmC;QAC3F,MAAM,SAAS,GAAG,MAAM,EAAE,SAAS,CAAC;QACpC,IAAI,CAAC,SAAS,EAAE,CAAC;YACf,MAAM,IAAI,IAAI,CAAC,YAAY,CAAC,2DAA2D,CAAC,CAAC;QAC3F,CAAC;QAED,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;IACrC,CAAC;IAED,MAAM,CAAC,kBAAkB,CAAC,WAA6C,EAAE,WAAmB;QAE1F,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;aACnC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAG,IAAI,MAAM,CAAC,OAAO,GAAG,WAAW,CAAC;aAClG,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;CACF;AAED,OAAO,EAAC,eAAe,EAAC,CAAC","sourcesContent":["// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Core from '../core/core.js';\nimport * as Graph from '../graph/graph.js';\nimport type * as Simulation from '../simulation/simulation.js';\n\nimport {\n  type Extras,\n  Metric,\n  type MetricCoefficients,\n  type MetricComputationDataInput,\n  type MetricResult,\n} from './Metric.js';\n\nclass MaxPotentialFID extends Metric {\n  static override get coefficients(): MetricCoefficients {\n    return {\n      intercept: 0,\n      optimistic: 0.5,\n      pessimistic: 0.5,\n    };\n  }\n\n  static override getOptimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getPessimisticGraph(dependencyGraph: Graph.Node): Graph.Node {\n    return dependencyGraph;\n  }\n\n  static override getEstimateFromSimulation(simulation: Simulation.Result, extras: Extras): Simulation.Result {\n    if (!extras.fcpResult) {\n      throw new Core.LanternError('missing fcpResult');\n    }\n\n    // Intentionally use the opposite FCP estimate, a more pessimistic FCP means that more tasks\n    // are excluded from the FID computation, so a higher FCP means lower FID for same work.\n    const fcpTimeInMs = extras.optimistic ? extras.fcpResult.pessimisticEstimate.timeInMs :\n                                            extras.fcpResult.optimisticEstimate.timeInMs;\n\n    const timings = MaxPotentialFID.getTimingsAfterFCP(\n        simulation.nodeTimings,\n        fcpTimeInMs,\n    );\n\n    return {\n      timeInMs: Math.max(...timings.map(timing => timing.duration), 16),\n      nodeTimings: simulation.nodeTimings,\n    };\n  }\n\n  static override compute(data: MetricComputationDataInput, extras?: Omit<Extras, 'optimistic'>): MetricResult {\n    const fcpResult = extras?.fcpResult;\n    if (!fcpResult) {\n      throw new Core.LanternError('FCP is required to calculate the Max Potential FID metric');\n    }\n\n    return super.compute(data, extras);\n  }\n\n  static getTimingsAfterFCP(nodeTimings: Simulation.Result['nodeTimings'], fcpTimeInMs: number):\n      Array<{duration: number}> {\n    return Array.from(nodeTimings.entries())\n        .filter(([node, timing]) => node.type === Graph.BaseNode.types.CPU && timing.endTime > fcpTimeInMs)\n        .map(([_, timing]) => timing);\n  }\n}\n\nexport {MaxPotentialFID};\n"]}