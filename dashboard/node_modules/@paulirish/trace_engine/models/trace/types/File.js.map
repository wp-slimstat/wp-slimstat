{"version":3,"file":"File.js","sourceRoot":"","sources":["../../../../../../../front_end/models/trace/types/File.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAgH7B,MAAM,UAAU,qBAAqB,CAAC,UAAsB;IAC1D,OAAO,UAAU,CAAC,IAAI,KAAK,YAAY,CAAC;AAC1C,CAAC;AAED,MAAM,UAAU,sBAAsB,CAAC,UAAsB;IAC3D,OAAO,UAAU,CAAC,IAAI,KAAK,aAAa,CAAC;AAC3C,CAAC;AAED,MAAM,UAAU,uBAAuB,CAAC,UAAsB;IAC5D,OAAO,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC;AAC5C,CAAC;AAkFD,MAAM,UAAU,qBAAqB,CAAC,GAAoB;IACxD,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC7B,MAAM,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAEtB,QAAQ,IAAI,EAAE,CAAC;QACb;YACE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC;gBAClB,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,OAAO,IAAI,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBACnG,MAAM,IAAI,KAAK,CAAC,2BAA2B,GAAG,EAAE,CAAC,CAAC;YACpD,CAAC;YACD,OAAO;gBACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,SAAS,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBACjC,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBAChC,WAAW,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;gBACnC,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;aACT,CAAC;QAC5B;YACE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC5F,MAAM,IAAI,KAAK,CAAC,yBAAyB,GAAG,EAAE,CAAC,CAAC;YAClD,CAAC;YACD,OAAO;gBACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;aACZ,CAAC;QACzB;YACE,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,CAAC,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC5F,MAAM,IAAI,KAAK,CAAC,+BAA+B,GAAG,EAAE,CAAC,CAAC;YACxD,CAAC;YACD,OAAO;gBACL,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC;gBACd,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;aACN,CAAC;QAC/B,iDAAuC,CAAC,CAAC,CAAC;YACxC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC;gBAC/D,MAAM,IAAI,KAAK,CAAC,oCAAoC,GAAG,EAAE,CAAC,CAAC;YAC7D,CAAC;YACD,OAAO;gBACL,IAAI;gBACJ,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;aACjC,CAAC;QACJ,CAAC;QAED;YACE,MAAM,IAAI,KAAK,CAAC,4BAA4B,GAAG,EAAE,CAAC,CAAC;IACvD,CAAC;AACH,CAAC","sourcesContent":["// Copyright 2023 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as SDK from '../../../core/sdk/sdk.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport type * as CrUXManager from '../../../models/crux-manager/crux-manager.js';\n\nimport type {TraceWindowMicro} from './Timing.js';\nimport type {Event, LegacyTimelineFrame, ProcessID, SampleIndex, ThreadID} from './TraceEvents.js';\n\nexport interface TraceFile {\n  traceEvents: readonly Event[];\n  metadata: MetaData;\n}\n\nexport interface Breadcrumb {\n  window: TraceWindowMicro;\n  child: Breadcrumb|null;\n}\n\nexport const enum DataOrigin {\n  CPU_PROFILE = 'CPUProfile',\n  TRACE_EVENTS = 'TraceEvents',\n}\n\n/**\n * The Entries link can have 3 stated:\n *  1. The Link creation is not started yet, meaning only the button that needs to be clicked to start creating the link is visible.\n *  2. Pending to event - the creation is started, but the entry that the link points to has not been chosen yet\n *  3. Link connected - final state, both entries present\n */\nexport const enum EntriesLinkState {\n  CREATION_NOT_STARTED = 'creation_not_started',\n  PENDING_TO_EVENT = 'pending_to_event',\n  CONNECTED = 'connected',\n}\n\nexport const enum EventKeyType {\n  RAW_EVENT = 'r',\n  SYNTHETIC_EVENT = 's',\n  PROFILE_CALL = 'p',\n  LEGACY_TIMELINE_FRAME = 'l',\n}\n\n/**\n * Represents an object that is saved in the file when user created annotations in the timeline.\n *\n * Expected to add more annotations.\n */\nexport interface SerializedAnnotations {\n  entryLabels: EntryLabelAnnotationSerialized[];\n  labelledTimeRanges: TimeRangeAnnotationSerialized[];\n  linksBetweenEntries: EntriesLinkAnnotationSerialized[];\n}\n\n/**\n * Represents an object that is used to store the Entry Label annotation that is created when a user creates a label for an entry in the timeline.\n */\nexport interface EntryLabelAnnotation {\n  type: 'ENTRY_LABEL';\n  entry: Event|LegacyTimelineFrame;\n  label: string;\n}\n\n/**\n * Represents an object that is used to store the Labelled Time Range Annotation that is created when a user creates a Time Range Selection in the timeline.\n */\nexport interface TimeRangeAnnotation {\n  type: 'TIME_RANGE';\n  label: string;\n  bounds: TraceWindowMicro;\n}\n\nexport interface EntriesLinkAnnotation {\n  type: 'ENTRIES_LINK';\n  state: EntriesLinkState;\n  entryFrom: Event;\n  entryTo?: Event;\n}\n\n/**\n * Represents an object that is saved in the file when a user creates a label for an entry in the timeline.\n */\nexport interface EntryLabelAnnotationSerialized {\n  entry: SerializableKey;\n  label: string;\n}\n\n/**\n * Represents an object that is saved in the file when a user creates a time range with a label in the timeline.\n */\nexport interface TimeRangeAnnotationSerialized {\n  bounds: TraceWindowMicro;\n  label: string;\n}\n\n/**\n * Represents an object that is saved in the file when a user creates a link between entries in the timeline.\n */\nexport interface EntriesLinkAnnotationSerialized {\n  entryFrom: SerializableKey;\n  entryTo: SerializableKey;\n}\n\n/**\n * `Annotation` are the user-created annotations that are saved into the metadata.\n * Those annotations are rendered on the timeline by `Overlays.ts`\n *\n * TODO: Implement other OverlayAnnotations (annotated time ranges, links between entries).\n * TODO: Save/load overlay annotations to/from the trace file.\n */\nexport type Annotation = EntryLabelAnnotation|TimeRangeAnnotation|EntriesLinkAnnotation;\n\nexport function isTimeRangeAnnotation(annotation: Annotation): annotation is TimeRangeAnnotation {\n  return annotation.type === 'TIME_RANGE';\n}\n\nexport function isEntryLabelAnnotation(annotation: Annotation): annotation is EntryLabelAnnotation {\n  return annotation.type === 'ENTRY_LABEL';\n}\n\nexport function isEntriesLinkAnnotation(annotation: Annotation): annotation is EntriesLinkAnnotation {\n  return annotation.type === 'ENTRIES_LINK';\n}\n\n// Serializable keys are created for trace events to be able to save\n// references to timeline events in a trace file. These keys enable\n// user modifications that can be saved. See go/cpq:event-data-json for\n// more details on the key format.\nexport type RawEventKey = `${EventKeyType.RAW_EVENT}-${number}`;\nexport type SyntheticEventKey = `${EventKeyType.SYNTHETIC_EVENT}-${number}`;\nexport type ProfileCallKey = `${EventKeyType.PROFILE_CALL}-${ProcessID}-${ThreadID}-${SampleIndex}-${Protocol.integer}`;\nexport type LegacyTimelineFrameKey = `${EventKeyType.LEGACY_TIMELINE_FRAME}-${number}`;\nexport type SerializableKey = RawEventKey|ProfileCallKey|SyntheticEventKey|LegacyTimelineFrameKey;\n\n// Serializable keys values objects contain data that maps the keys to original Trace Events\nexport interface RawEventKeyValues {\n  type: EventKeyType.RAW_EVENT;\n  rawIndex: number;\n}\n\nexport interface SyntheticEventKeyValues {\n  type: EventKeyType.SYNTHETIC_EVENT;\n  rawIndex: number;\n}\n\nexport interface ProfileCallKeyValues {\n  type: EventKeyType.PROFILE_CALL;\n  processID: ProcessID;\n  threadID: ThreadID;\n  sampleIndex: SampleIndex;\n  protocol: Protocol.integer;\n}\n\nexport interface LegacyTimelineFrameKeyValues {\n  type: EventKeyType.LEGACY_TIMELINE_FRAME;\n  rawIndex: number;\n}\n\nexport type SerializableKeyValues =\n    RawEventKeyValues|ProfileCallKeyValues|SyntheticEventKeyValues|LegacyTimelineFrameKeyValues;\n\nexport interface Modifications {\n  entriesModifications: {\n    // Entries hidden by the user\n    hiddenEntries: SerializableKey[],\n    // Entries that parent a hiddenEntry\n    expandableEntries: SerializableKey[],\n  };\n  initialBreadcrumb: Breadcrumb;\n  annotations: SerializedAnnotations;\n}\n\n/**\n * Trace metadata that we persist to the file. This will allow us to\n * store specifics for the trace, e.g., which tracks should be visible\n * on load.\n */\nexport interface MetaData {\n  source?: 'DevTools';\n  startTime?: string;\n  emulatedDeviceTitle?: string;\n  // Only set if network throttling is active.\n  networkThrottling?: string;\n  // Only set if network throttling is active.\n  networkThrottlingConditions?: Omit<SDK.NetworkManager.Conditions, 'title'>;\n  // Only set if CPU throttling is active.\n  cpuThrottling?: number;\n  hardwareConcurrency?: number;\n  dataOrigin?: DataOrigin;\n  enhancedTraceVersion?: number;\n  modifications?: Modifications;\n  cruxFieldData?: CrUXManager.PageResult[];\n  /** Currently only stores JS maps, not CSS. This never stores data url source maps. */\n  sourceMaps?: MetadataSourceMap[];\n}\n\ninterface MetadataSourceMap {\n  url: string;\n  sourceMapUrl: string;\n  sourceMap: SDK.SourceMap.SourceMapV3;\n}\n\nexport type Contents = TraceFile|Event[];\n\nexport function traceEventKeyToValues(key: SerializableKey): SerializableKeyValues {\n  const parts = key.split('-');\n  const type = parts[0];\n\n  switch (type) {\n    case EventKeyType.PROFILE_CALL:\n      if (parts.length !== 5 ||\n          !(parts.every((part, i) => i === 0 || typeof part === 'number' || !isNaN(parseInt(part, 10))))) {\n        throw new Error(`Invalid ProfileCallKey: ${key}`);\n      }\n      return {\n        type: parts[0],\n        processID: parseInt(parts[1], 10),\n        threadID: parseInt(parts[2], 10),\n        sampleIndex: parseInt(parts[3], 10),\n        protocol: parseInt(parts[4], 10),\n      } as ProfileCallKeyValues;\n    case EventKeyType.RAW_EVENT:\n      if (parts.length !== 2 || !(typeof parts[1] === 'number' || !isNaN(parseInt(parts[1], 10)))) {\n        throw new Error(`Invalid RawEvent Key: ${key}`);\n      }\n      return {\n        type: parts[0],\n        rawIndex: parseInt(parts[1], 10),\n      } as RawEventKeyValues;\n    case EventKeyType.SYNTHETIC_EVENT:\n      if (parts.length !== 2 || !(typeof parts[1] === 'number' || !isNaN(parseInt(parts[1], 10)))) {\n        throw new Error(`Invalid SyntheticEvent Key: ${key}`);\n      }\n      return {\n        type: parts[0],\n        rawIndex: parseInt(parts[1], 10),\n      } as SyntheticEventKeyValues;\n    case EventKeyType.LEGACY_TIMELINE_FRAME: {\n      if (parts.length !== 2 || Number.isNaN(parseInt(parts[1], 10))) {\n        throw new Error(`Invalid LegacyTimelineFrame Key: ${key}`);\n      }\n      return {\n        type,\n        rawIndex: parseInt(parts[1], 10),\n      };\n    }\n\n    default:\n      throw new Error(`Unknown trace event key: ${key}`);\n  }\n}\n"]}